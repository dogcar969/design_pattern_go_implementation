# Go 设计模式

亮点：

1. 代理模式 gin 中间件模拟
2. 解释器模式 命令行指令解析
3. 迭代器模式 实现类似js的forEach，map函数
4. 备忘录模式 实现了文本的保存，加载，撤销，重做
5. 访问者模式 实现了电脑类的更新，包括内存的读写，cpu的计算

[TOC]



## 1. 工厂模式

定义一个专门用来创建对象的类，使得创建对象与使用对象分离

简单工厂模式，使用一个工厂创建多个类，不符合开闭原则

工厂模式，一个工厂对应一个类，符合开闭原则

**使用场景**

有很多实现了同一接口的类时

有字段需要设定初始值但是在使用时应是私有字段时

生成复杂对象时

**实现**

简单工厂模式：一个厨房可以根据输入的类名制作沙拉，汉堡，派

工厂模式：每个食物都有其一一对应的工厂

## 2. 抽象工厂模式

创建工厂的工厂

一个创建工厂的工厂可以处理多个大类，一个具体工厂可以处理一个大类里的多个类

违反开闭原则

**实现**

厨房水吧实现了店铺接口

可通过建筑师类生成店铺，

然后在店铺中生成饮料或食物

## 3. 单例模式

确保一个类只有一个实例

把实例放到另一个包里，对外不可见，getter 只返回这个实例

**使用场景**

实例创建，使用，销毁很消耗资源

实例需要频繁创建销毁

**实现**

根据不同包之间的可见性，在instance包中定义了唯一的instance和GetInstance函数

## 4. 建造者模式

如果对象的创建过程复杂并且有很多可以不同初始化的字段时（例如 orm 的数据库连接有很多配置项）使用一个对象来创建该对象

**实现**

厨师可以根据点单的字符串数组制造对应的套餐对象

## 5. 原型模式

使用已有对象创建新的实例

**使用场景**

直接创建消耗很多资源

运行时指定实例化

类只有几种状态组合

**实现**

设立了一个数据库查询的情形

只有在初始化和数据库被修改的时候会重新检索，在获取数据时直接从cache模板中获取，比每次都检索用时会少很多

## 6. 适配器模式

把多个接口不同的类通过新加一个类的方式统一接口。

**实现**

设立了一个sql和sqlite的打开方式不一样的情形（sqlite可能需要新建）

设置数据库适配器可以根据数据库类型自动选择不同的打开方式

## 7. 桥接模式

仅使用接口的函数来创造一个任何实现了该接口的具体类都可以用的函数

如果使用两个或多个接口进行交互的话可以避免多个具体类交互时产生大量中间类

例如，如果有 a,b,c 个类需要相互交互，就需要 a\*b\*c 个中间类，但如果桥接的话就只需要一个

**实现**

使用tcp和http对象发送图像和json，bridge类可以根据连接类和内容类来决定发送过程

## 8. 组合模式

在一个结构体中使用结构体指针来包含同一种结构体的字段

对每一层结构体使用同样的函数（父结构体在函数中调用子结构体的该函数）

国--->省--->市---> 区

逐级向下询问，直到没有子节点

再将数据向上汇总（如果有数据）

**使用场景**

统一处理对象的树形结构

**实现**

军队中单位通知下属单位统计人数并将其汇总得到单位的人数，这个过程直到没有下属单位为止。

## 9. 装饰器模式

装饰器有基础类的字段，可通过在函数中调用基础类并做一些其他的功能来进行扩展

由于 go 可以把函数当变量，所以也可以创建钩子函数

**实现**

print对象可以进行基础的输出，printDecor对象可以决定输出的前缀，printWithhooks可以在输出前后使用传入的函数。

## 10. 外观模式

把复杂的内部系统的功能包装到一个类里面，在使用时只需要和这个类交互而不用考虑内部系统

**使用场景**

使用系统不需要了解，处理内部系统

系统复杂，需要一个专门用来使用系统的类

**实现**

后端需要与数据库，数据处理框架，网络交互。构建了api对象，使处理请求只用和api对象交互。

## 11. 享元模式

需要大量资源消耗来创建销毁的类导致频繁使用时会有性能问题时，使用共享对象来避免频繁的创建销毁

**实现**

存在有限的数据库连接，可以指定连接传输数据。

使用goroutine进行并发，如果冲突会报“Connection conflict”错误。

## 12. 代理模式

在客户端和内部实现之间添加一个中间层，可以在中间层实现认证，修改输入输出等功能

在代理类中有内部实现的引用

**实现**

引用：

代理类引用图片类，如果图片类没有内容则先加载，如果有内容直接输出。

中间件：

模拟gin的中间件。可以根据next()分割requestHandler前后的操作,使用context对象的指针在每个中间件以及handler之间传递信息。

## 13. 责任链模式

一个请求由多个对象链式传递，有一个或多个对请求进行处理

减少请求和处理之间的耦合

**实现**

有请求handler，响应handler，错误handler，流程为

请求handler -> 响应handler -> 错误handler

请求handler肯定会被触发，如果内容不是error由响应handler触发，如果是error会在响应handler什么都不做留到错误handler处理。

## 14. 命令模式

将请求封装为对象，可对请求排队，记录请求，撤销

**实现**

将命令封装为有名字，任何参数，任何参数与返回值的handler的对象

客户端（client）负责处理命令（command）

有全局变量data表示系统的状态

每一次处理命令之前，都会将状态记录在客户端的历史记录中

客户端有命令channel，有10的缓存长度。如果channel

在控制台输入命令编号可以执行命令

有撤销命令

在命令执行前会输出命令的名字作为日志

## 15. 解释器模式

使用符合给定文法的文本来表示指令，使用解释器来解析文本后执行

**实现**

一个模拟控制台命令解析的程序

使用空格分割，第一个是命令的名字

第偶数个是参数名，可以是全名(--fullName)也可以是别名(-fn)

第奇数个（除了第一个）是参数的值

可以创造Command并使用Command（将Command加入到commands数组中）

可以输出Command的帮助字段，以及Command每个参数的帮助字段

## 16. 迭代器模式

提供顺序访问对象的各个元素的方法，不暴露内部表示

hasNext() next()

**实现**

使用泛型构造任何类型都可以使用的迭代器

使用hasNext() next()设计了类似js的forEach函数以及map函数（限制输出为原类型的map函数以及不限制输出类型的map函数）

## 17. 中介者模式

使用一个中介对象封装对象交互，将网状结构更改为星状结构

**实现**

在码头间传输的情况

假设码头无法知道各码头的容量情况，只有送到了才能根据目的地的情况决定是否成果

但中介者（导航）知道所有码头的容量，所有码头与中介者交互可以把失败的传输在开始前终止。

## 18. 备忘录模式

版本控制，撤销，重做，保存，加载

由被保存的对象本身实现保存，加载来保证封装不改变

**实现**： 实现保存，加载，撤销，重做的字符串编辑

## 19. 观察者模式

当对象状态发生改变时，依赖者会收到通知并自动更新

**实现**

彩票系统，每5分钟一结算，根据随机数决定赢家

每次结算会让用户得到赢家的信息。赢家可接收奖励（记录赢的次数+1）

## 20. 状态模式

对象在内部状态不同时改变行为

**实现**

上下文对象（cat）可以在不同的状态（vibe）下有不同的动作

hungry -> 吃饭

sleepy -> 睡觉

boring -> 打豆豆

## 21. 策略模式

封装算法为策略对象，和一个行为随着策略对象改变的对象

**实现**

设计一个负责文件关闭的对象，只关闭 和 清空并关闭 的两个策略对象

文件关闭对象可以根据策略对象改变行为。

由于对文件路径不熟悉使用了绝对路径

## 22. 模板模式

父类定义算法框架，将一些步骤延迟到子类中实现，使子类在不改变算法结构时改变特定步骤

**实现**

一个负责输出的对象，可以接收一个函数和一个信息（由于结构体函数不能定义泛型所以是any）

据此设计了错误的输出方式和带颜色的输出方式

## 23. 访问者模式

在程序内部定义接受访问的接口，并传递组件自身。访问者负责对组件进行修改与更新。

**实现**

模拟一个可更新驱动的电脑，有内存和cpu两个部件

内存使用切片作为存储，切片作为输出（代替寄存器），初始开辟10个字

cpu可以使用内存的操作以及进行计算。

一开始什么操作都没有，在添加了内存写，内存读，cpu加后，可完成加法操作。
